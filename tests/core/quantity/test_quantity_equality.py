import pytest

from quantium.core.dimensions import LENGTH, TIME
from quantium.core.quantity import Quantity
from quantium.core.unit import LinearUnit
from quantium.units.registry import DEFAULT_REGISTRY as ureg
from quantium.units import u

# -------------------------------
# Basic quantity equality (regressions)
# -------------------------------

def test_less_than_or_equal():
    """
    Tests the __le__ (<=) operator, which is auto-generated
    by @total_ordering from __lt__ and __eq__.
    """
    # 1. Test case from your example: less than
    q_100_cm = Quantity(100.0, u.cm)
    q_1000_cm = Quantity(1000.0, u.cm)
    assert q_100_cm <= q_1000_cm
    assert not (q_1000_cm <= q_100_cm) # Check inverse

    # 2. Test case from your example: equal
    q_1_m = Quantity(1.0, u.m)
    assert q_100_cm <= q_1_m
    assert q_1_m <= q_100_cm # Check both directions

    # 3. Test case: greater than
    q_10_km = Quantity(10.0, u.km)
    assert not (q_10_km <= q_1_m)
    assert q_1_m <= q_10_km

    # 4. Test fuzzy equality (due to isclose in __eq__)
    # q_eq_fuzzy should be "equal" to q_1_m, thus "<=" is True
    q_eq_fuzzy = Quantity(1.0 + 1e-13, u.m)
    assert q_1_m <= q_eq_fuzzy
    assert q_eq_fuzzy <= q_1_m
    
    # 5. Test strict inequality (where __lt__ is used)
    # q_gt_strict is *not* "isclose", so it's strictly greater
    q_gt_strict = Quantity(1.0 + 1e-9, u.m)
    assert q_1_m <= q_gt_strict
    assert not (q_gt_strict <= q_1_m)

    # 6. Test dimension mismatch
    q_1_s = Quantity(1.0, u.s)
    with pytest.raises(TypeError, match="different dimensions"):
        # This must raise an error
        _ = q_1_m <= q_1_s
        
    with pytest.raises(TypeError, match="different dimensions"):
        # Check inverse comparison as well
        _ = q_1_s <= q_1_m

def test_less_than():
    """
    Tests the __lt__ (<) operator directly.
    """
    # 1. Test with Time units
    q_100_us = Quantity(100.0, u.us) # 100e-6 s
    q_1_ms = Quantity(1.0, u.ms)     # 1000e-6 s
    assert q_100_us < q_1_ms
    assert not (q_1_ms < q_100_us) # Check inverse

    # 2. Test equality case (should be False)
    q_1000_us = Quantity(1000.0, u.us)
    assert not (q_1000_us < q_1_ms)
    assert not (q_1_ms < q_1000_us)

    # 3. Test fuzzy equality case (should be False)
    q_fuzzy_ms = Quantity(1.0 + 1e-13, u.ms)
    assert not (q_1_ms < q_fuzzy_ms)
    assert not (q_fuzzy_ms < q_1_ms)

    # 4. Test strict inequality (just barely less)
    q_strict_lt = Quantity(1.0 - 1e-9, u.ms)
    assert q_strict_lt < q_1_ms
    assert not (q_1_ms < q_strict_lt)

    # 5. Test dimension mismatch
    q_1_g = Quantity(1.0, u.g)
    with pytest.raises(TypeError, match="different dimensions"):
        _ = q_100_us < q_1_g

def test_greater_than():
    """
    Tests the __gt__ (>) operator, auto-generated by @total_ordering.
    """
    # 1. Test with Energy units
    q_1_kJ = Quantity(1.0, u.kJ)   # 1000 J
    q_500_J = Quantity(500.0, u.J) # 500 J
    assert q_1_kJ > q_500_J
    assert not (q_500_J > q_1_kJ) # Check inverse

    # 2. Test equality case (should be False)
    q_1000_J = Quantity(1000.0, u.J)
    assert not (q_1_kJ > q_1000_J)
    assert not (q_1000_J > q_1_kJ)

    # 3. Test fuzzy equality case (should be False)
    q_fuzzy_kJ = Quantity(1.0 + 1e-13, u.kJ)
    assert not (q_1_kJ > q_fuzzy_kJ)
    assert not (q_fuzzy_kJ > q_1_kJ)

    # 4. Test strict inequality (just barely greater)
    q_strict_gt = Quantity(1.0 + 1e-9, u.kJ)
    assert q_strict_gt > q_1_kJ
    assert not (q_1_kJ > q_strict_gt)

    # 5. Test dimension mismatch
    q_1_N = Quantity(1.0, u.N)
    with pytest.raises(TypeError, match="different dimensions"):
        _ = q_1_kJ > q_1_N

def test_greater_than_or_equal():
    """
    Tests the __ge__ (>=) operator, auto-generated by @total_ordering.
    """
    # 1. Test with Current units (greater)
    q_2_A = Quantity(2.0, u.A)
    q_1000_mA = Quantity(1000.0, u.mA) # 1.0 A
    assert q_2_A >= q_1000_mA
    assert not (q_1000_mA >= q_2_A) # Check inverse

    # 2. Test equality case (should be True)
    q_1_A = Quantity(1.0, u.A)
    assert q_1_A >= q_1000_mA
    assert q_1000_mA >= q_1_A # Check both directions
    
    # 3. Test with Power units (less)
    q_1_W = Quantity(1.0, u.W)
    q_100_W = Quantity(100.0, u.W)
    assert q_100_W >= q_1_W
    assert not (q_1_W >= q_100_W)

    # 4. Test fuzzy equality (should be True)
    q_fuzzy_A = Quantity(1.0 + 1e-13, u.A)
    assert q_1_A >= q_fuzzy_A
    assert q_fuzzy_A >= q_1_A
    
    # 5. Test strict inequality (greater)
    q_strict_A = Quantity(1.0 + 1e-9, u.A)
    assert q_strict_A >= q_1_A
    assert not (q_1_A >= q_strict_A)

    # 6. Test dimension mismatch
    q_1_C = Quantity(1.0, u.C)
    with pytest.raises(TypeError, match="different dimensions"):
        _ = q_1_A >= q_1_C

def test_not_equal():
    """Tests the __ne__ (!=) operator."""
    
    # 1. Different Dimensions (should be True)
    q_m = Quantity(1.0, u.m)
    q_kg = Quantity(1.0, u.kg)
    assert q_m != q_kg

    # 2. Same Dimension, Different Values (should be True)
    q_1_m = Quantity(1.0, u.m)
    q_2_m = Quantity(2.0, u.m)
    assert q_1_m != q_2_m

    # 3. Same Dimension, Same Values (should be False)
    q_100_cm = Quantity(100.0, u.cm) # _mag_si = 1.0
    assert not (q_1_m != q_100_cm) # not (1.0m != 1.0m) -> not(False)

    # 4. Fuzzy Equality (should be False)
    # These are "equal" via isclose, so they are *not* "not equal"
    q_fuzzy = Quantity(1.0 + 1e-13, u.m)
    assert q_1_m == q_fuzzy # Prerequisite check
    assert not (q_1_m != q_fuzzy) # The real test

    # 5. Strictly Not Equal (just outside tolerance) (should be True)
    q_strict_ne = Quantity(1.0 + 1e-9, u.m)
    assert not (q_1_m == q_strict_ne) # Prerequisite check
    assert q_1_m != q_strict_ne # The real test


# -------------------------------
# Quantity equality (regressions)
# -------------------------------

@pytest.mark.regression(reason="Quantities equal when SI magnitude and unit (by dim+scale) match")
def test_quantity_equality_same_si_and_equivalent_units():
    # Build equivalent units with different names but same dim/scale
    kg = ureg.get("kg")
    m = ureg.get("m")
    s = ureg.get("s")
    N = ureg.get("N")
    unit_from_bases = kg * m / (s ** 2)   # equals N by dim+scale

    q1 = 10 * N
    q2 = 10 * unit_from_bases

    # _mag_si identical & units compare equal (ignoring name)
    assert q1 == q2


@pytest.mark.regression(reason="Issue: #28 Quantities with same SI magnitude but different unit scales should be equal")
def test_quantity_equality_same_si_magnitude_different_units():
    # 100 cm and 1 m have same SI magnitude (both represent 1.0 m in SI),
    # and __eq__ now compares normalized SI magnitudes and dimensions, not unit identity.
    m  = LinearUnit("m", 1.0, LENGTH)
    cm = LinearUnit("cm", 0.01, LENGTH)

    q_cm = 100 * cm  # _mag_si = 1.0
    q_m  = 1 * m     # _mag_si = 1.0

    # They should now compare equal because their physical values are identical.
    assert q_cm == q_m


@pytest.mark.regression(reason="Quantities with different SI magnitudes must not be equal even if units match")
def test_quantity_inequality_different_si_magnitude_same_unit():
    m = LinearUnit("m", 1.0, LENGTH)
    q1 = 2 * m
    q2 = 3 * m
    assert q1 != q2


@pytest.mark.regression(reason="Quantity __eq__ returns NotImplemented for incompatible types")
def test_quantity_equality_with_incompatible_type_returns_notimplemented():
    m = LinearUnit("m", 1.0, LENGTH)
    q = 1 * m
    assert Quantity.__eq__(q, "not-a-quantity") is NotImplemented
    assert (q == "not-a-quantity") is False





@pytest.mark.regression(reason="Quantity equality consistent when units simplify to same dim/scale")
def test_quantity_equality_when_units_simplify_to_same_dim_and_scale():
    # Build two different-looking but equivalent units for velocity
    m = LinearUnit("m", 1.0, LENGTH)
    s = LinearUnit("s", 1.0, TIME)
    ms = m / s

    # Another velocity path: (m*s)/s^2 simplifies to m/s
    alt = (m * s) / (s ** 2)
    assert ms == alt  # unit equality check

    q1 = 12 * ms
    q2 = 12 * alt
    assert q1 == q2